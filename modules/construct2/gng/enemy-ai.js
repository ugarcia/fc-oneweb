// Generated by CoffeeScript 1.6.3
(function() {
  window.EnemyAI = (function() {
    EnemyAI.states = {
      SEEKING: 0,
      PURSUING: 1,
      SHOOTING: 2,
      PUSHING: 3,
      JUMPING_ON: 4,
      HALT: 5
    };

    EnemyAI.levels = {
      BASIC: 0,
      REAL: 1,
      IMPOSSIBLE: 2
    };

    EnemyAI.prototype.attackCycle = [EnemyAI.states.SHOOTING, EnemyAI.states.JUMPING_ON, EnemyAI.states.PUSHING];

    EnemyAI.prototype.haltStateDuration = 0;

    EnemyAI.prototype.haltMaxDuration = 0;

    EnemyAI.prototype.lastAttackState = null;

    EnemyAI.prototype.obj = null;

    EnemyAI.prototype.target = null;

    EnemyAI.prototype.state = EnemyAI.states.SEEKING;

    EnemyAI.prototype.level = EnemyAI.levels.BASIC;

    EnemyAI.prototype.attackDistance = 100;

    EnemyAI.prototype.actionTimeout = 0;

    EnemyAI.prototype.jumpDir = 0;

    function EnemyAI(obj, target, level, attackDistance) {
      this.obj = obj;
      this.target = target;
      this.level = level;
      this.attackDistance = attackDistance;
    }

    EnemyAI.prototype.getState = function() {
      return this.state;
    };

    EnemyAI.prototype.setState = function(state) {
      this.state = state;
      this.haltStateDuration = 0;
      return console.log(this.state);
    };

    EnemyAI.prototype.getObj = function() {
      return this.obj;
    };

    EnemyAI.prototype.setObj = function(obj) {
      this.obj = obj;
    };

    EnemyAI.prototype.getTarget = function() {
      return this.target;
    };

    EnemyAI.prototype.setTarget = function(target) {
      return this.target = target.instances[0];
    };

    EnemyAI.prototype.getLevel = function() {
      return this.level;
    };

    EnemyAI.prototype.setLevel = function(level) {
      this.level = level;
    };

    EnemyAI.prototype.getAttackDistance = function() {
      return this.attackDistance;
    };

    EnemyAI.prototype.setAttackDistance = function(attackDistance) {
      this.attackDistance = attackDistance;
    };

    EnemyAI.prototype.nextAttackState = function() {
      var i;
      this.lastAttackState || (this.lastAttackState = Math.floor(this.attackCycle.length * Math.random()) + EnemyAI.states.SHOOTING);
      for (i in this.attackCycle) {
        if (this.attackCycle[i] === this.lastAttackState) {
          return this.attackCycle[(i + 1) % this.attackCycle.length];
        }
      }
    };

    EnemyAI.prototype.attack = function() {
      switch (this.state) {
        case EnemyAI.states.PUSHING:
          return this.actionTimeout = 0;
        case EnemyAI.states.JUMPING_ON:
          this.actionTimeout = 1;
          return this.jumpDir = this.obj.x > this.target.x ? -1 : this.obj.x < this.target.x ? 1 : 0;
        case EnemyAI.states.SHOOTING:
          return this.obj.runtime.trigger(this.obj.ai.behavior.cnds.OnAttack, this.obj);
      }
    };

    EnemyAI.prototype.update = function(dt) {
      var isByWall, isJumping;
      this.haltStateDuration += dt;
      this.actionTimeout -= dt;
      if (this.state !== EnemyAI.states.PURSUING && (this.obj.x > this.target.x + this.attackDistance || this.obj.x < this.target.x - this.attackDistance)) {
        this.setState(EnemyAI.states.PURSUING);
      }
      if (this.state !== EnemyAI.states.SEEKING && !this.obj.lineOfSight.hasLOSto(this.target.x, this.target.y)) {
        this.setState(EnemyAI.states.PURSUING);
      }
      switch (this.state) {
        case EnemyAI.states.SEEKING:
          if (this.obj.lineOfSight.hasLOSto(this.target.x, this.target.y)) {
            return this.setState(EnemyAI.states.PURSUING);
          }
          break;
        case EnemyAI.states.PURSUING:
          this.obj.platform.simleft = this.obj.x > this.target.x + this.attackDistance;
          this.obj.platform.simright = this.obj.x < this.target.x - this.attackDistance;
          isByWall = this.obj.platform.behavior.cnds.IsByWall;
          this.obj.platform.simjump = isByWall.call(this.obj.platform, 0) || isByWall.call(this.obj.platform, 1);
          if (this.obj.x >= this.target.x - this.attackDistance && this.obj.x <= this.target.x + this.attackDistance) {
            return this.setState(EnemyAI.states.HALT);
          }
          break;
        case EnemyAI.states.HALT:
          if (this.haltStateDuration > this.haltMaxDuration) {
            this.lastAttackState = this.nextAttackState();
            this.setState(this.lastAttackState);
            return this.attack();
          }
          break;
        case EnemyAI.states.PUSHING:
          if (this.actionTimeout > 0) {
            this.obj.platform.simleft = this.obj.x > this.target.x + 10;
            return this.obj.platform.simright = this.obj.x < this.target.x - 10;
          } else {
            return this.setState(EnemyAI.states.HALT);
          }
          break;
        case EnemyAI.states.JUMPING_ON:
          console.log(this.obj.runtime.getCurrentEventStack());
          if (this.actionTimeout > 0) {
            this.obj.platform.simleft = this.jumpDir < 0;
            this.obj.platform.simright = this.jumpDir > 0;
            isJumping = this.obj.platform.behavior.cnds.IsJumping;
            return this.obj.platform.simjump = !isJumping.call(this.obj.platform);
          } else {
            return this.setState(EnemyAI.states.HALT);
          }
      }
    };

    return EnemyAI;

  })();

}).call(this);
