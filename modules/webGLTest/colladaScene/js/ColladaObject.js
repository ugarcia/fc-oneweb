// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.ColladaObject = (function() {
    ColladaObject.prototype.app = null;

    ColladaObject.prototype.src = null;

    ColladaObject.prototype.scale = 1;

    ColladaObject.prototype.physics = false;

    ColladaObject.prototype.mass = 1;

    ColladaObject.prototype.speed = 0.1;

    ColladaObject.prototype.currentAnimation = null;

    ColladaObject.prototype.frame = 0;

    ColladaObject.prototype.skin = null;

    ColladaObject.prototype.morph = null;

    ColladaObject.prototype.mesh = null;

    ColladaObject.prototype.scene = null;

    ColladaObject.prototype.kAnimations = null;

    ColladaObject.prototype.kfAnimations = null;

    ColladaObject.prototype.obj = null;

    function ColladaObject(app, src, scale, physics, animations) {
      this.app = app;
      this.src = src;
      this.scale = scale;
      this.physics = physics;
      this.animations = animations;
      this.update = __bind(this.update, this);
    }

    ColladaObject.prototype.load = function(cb) {
      var _this = this;
      return require(["" + this.app.urlRoot + "/lib/js/ColladaLoader.js"], function() {
        var loader;
        loader = new THREE.ColladaLoader();
        loader.options.convertUpAxis = true;
        return loader.load(_this.src, function(collada) {
          console.log(collada);
          _this.scene = collada.scene;
          _this.skin = collada.skins[0];
          _this.morph = collada.morphs[0];
          _this.mesh = collada.meshes[0];
          _this.kAnimations = collada.animations;
          if (!!cb) {
            return cb();
          }
        });
      });
    };

    ColladaObject.prototype.init = function(scene) {
      var animHandler, aux, i, _fn, _i, _ref, _ref1, _ref2, _ref3, _ref4,
        _this = this;
      this.scene.scale.x = this.scene.scale.y = this.scene.scale.z = this.scale;
      this.scene.updateMatrix();
      aux = (_ref = (_ref1 = (_ref2 = this.skin) != null ? _ref2 : this.morph) != null ? _ref1 : this.mesh) != null ? _ref : this.scene;
      if ((_ref3 = aux.geometry) != null) {
        _ref3.center();
      }
      if (this.physics) {
        this.obj = this.skin = new Physijs.BoxMesh(aux.geometry, aux.material, this.mass);
        this.obj.setAngularFactor(new THREE.Vector3(0, 1, 0));
      } else {
        this.obj = aux;
      }
      this.obj.scale.x = this.obj.scale.y = this.obj.scale.z = this.scale;
      this.obj.updateMatrix();
      if (this.kAnimations && this.kAnimations.length) {
        this.kfAnimations = [];
        animHandler = THREE.AnimationHandler;
        _fn = function(i) {
          var animation, kfAnimation;
          animation = _this.kAnimations[i];
          animHandler.add(animation);
          kfAnimation = new THREE.KeyFrameAnimation(animation.node, animation.name);
          kfAnimation.timeScale = 1;
          _this.kfAnimations.push(kfAnimation);
          return kfAnimation.play(false, 0);
        };
        for (i = _i = 0, _ref4 = this.kAnimations.length - 1; 0 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
          _fn(i);
        }
        this.frame = 0;
        this.setAnimation(0);
      }
      return scene.add(this.obj);
    };

    ColladaObject.prototype.update = function(delta) {
      var currLength, i, _i, _ref, _results;
      if (this.kfAnimations && this.kfAnimations.length) {
        currLength = this.currentAnimation.end - this.currentAnimation.start;
        if (this.frame < currLength - 1 || this.currentAnimation.looping) {
          this.frame = (this.frame + 1) % currLength;
        } else {
          this.setAnimation(0);
        }
        _results = [];
        for (i = _i = 0, _ref = this.kfAnimations.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.kfAnimations[i].setFrame(this.currentAnimation.start + this.frame));
        }
        return _results;
      }
    };

    ColladaObject.prototype.getPosition = function() {
      return this.obj.position;
    };

    ColladaObject.prototype.setAnimation = function(animation) {
      this.currentAnimation = animation;
      return this.frame = 0;
    };

    ColladaObject.prototype.setAnimationByName = function(animationName) {
      return this.setAnimation(this.animations[animationName]);
    };

    ColladaObject.prototype.getAnimationByName = function(animationName) {
      return this.animations[animationName];
    };

    ColladaObject.prototype.getAnimationByStartKey = function(key) {
      var anim;
      for (anim in this.animations) {
        if (this.animations[anim].start === key) {
          return this.animations[anim];
        }
      }
    };

    ColladaObject.prototype.getNextAnimation = function() {
      return this.getAnimationByStartKey((this.currentAnimation.end + 1) % (this.getMaxFrames() + 1));
    };

    ColladaObject.prototype.setNextAnimation = function() {
      return this.setAnimation(this.getNextAnimation());
    };

    ColladaObject.prototype.getMaxFrames = function() {
      var anim, maxFrames;
      maxFrames = 0;
      for (anim in this.animations) {
        if (this.animations[anim].end > maxFrames) {
          maxFrames = this.animations[anim].end;
        }
      }
      return maxFrames;
    };

    ColladaObject.prototype.move = function(direction) {
      var angle, angleDelta, axis, from;
      if (direction) {
        from = this.obj.getForward();
        angle = from.angleTo(direction);
        if (angle < 0.4 * Math.PI) {
          this.obj.position.add(from.multiplyScalar(this.speed));
          if (!!this.physics) {
            this.obj.__dirtyPosition = true;
          }
        }
        if (angle > 0.02 * Math.PI) {
          axis = angle === Math.PI ? this.obj.up : new THREE.Vector3().crossVectors(from, direction).normalize();
          angleDelta = Math.min(this.speed * Math.PI, angle);
          this.obj.rotateOnAxis(new THREE.Vector3(0, axis.y, 0), angleDelta);
          if (!!this.physics) {
            return this.obj.__dirtyRotation = true;
          }
        }
      } else {

      }
    };

    ColladaObject.prototype.attack = function() {};

    ColladaObject.prototype.debugLines = function(obj) {
      var i, _i, _ref, _results,
        _this = this;
      if (obj && obj.children && obj.children.length) {
        _results = [];
        for (i = _i = 0, _ref = obj.children.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push((function(i) {
            var geometry;
            geometry = new THREE.Geometry();
            geometry.vertices.push(obj.children[i].position);
            geometry.vertices.push(new THREE.Vector3());
            obj.add(new THREE.Line(geometry));
            return _this.debugLines(obj.children[i]);
          })(i));
        }
        return _results;
      }
    };

    return ColladaObject;

  })();

}).call(this);
