// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.ColladaObject = (function() {

    ColladaObject.prototype.app = null;

    ColladaObject.prototype.src = null;

    ColladaObject.prototype.scale = 1;

    ColladaObject.prototype.animations = null;

    ColladaObject.prototype.physics = false;

    ColladaObject.prototype.mass = 1;

    ColladaObject.prototype.speed = 0.1;

    ColladaObject.prototype.currentAnimation = null;

    ColladaObject.prototype.frame = 0;

    ColladaObject.prototype.skin = null;

    ColladaObject.prototype.morph = null;

    ColladaObject.prototype.mesh = null;

    ColladaObject.prototype.scene = null;

    ColladaObject.prototype.kAnimations = null;

    ColladaObject.prototype.kfAnimations = [];

    ColladaObject.prototype.obj = null;

    ColladaObject.prototype.skel = null;

    ColladaObject.prototype.hand = null;

    function ColladaObject(app, src, scale, physics, animations) {
      this.app = app;
      this.src = src;
      this.scale = scale;
      this.physics = physics;
      this.animations = animations;
      this.update = __bind(this.update, this);

    }

    ColladaObject.prototype.load = function(cb) {
      var _this = this;
      return require(["" + this.app.urlRoot + "/lib/js/ColladaLoader.js"], function() {
        var loader;
        loader = new THREE.ColladaLoader();
        loader.options.convertUpAxis = true;
        return loader.load(_this.src, function(collada) {
          console.log(collada);
          _this.skin = collada.skins[0];
          _this.scene = collada.scene;
          _this.morph = collada.morphs[0];
          _this.mesh = collada.meshes[0];
          _this.kAnimations = collada.animations;
          if (!!cb) {
            return cb();
          }
        });
      });
    };

    ColladaObject.prototype.init = function(scene) {
      var addLines, animHandler, aux, i, offset, skelKeys, _fn, _fn1, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4, _ref5,
        _this = this;
      this.scene.scale.x = this.scene.scale.y = this.scene.scale.z = this.scale;
      this.scene.updateMatrix();
      aux = (_ref = (_ref1 = (_ref2 = this.skin) != null ? _ref2 : this.morph) != null ? _ref1 : this.mesh) != null ? _ref : this.scene;
      offset = new THREE.Vector3().subVectors(aux.position, aux.geometry.getCenter());
      this.skel = this.scene.getChildByName("ZOMBIE");
      this.skel.position.sub(offset);
      if ((_ref3 = aux.geometry) != null) {
        _ref3.center();
      }
      if (this.physics) {
        this.obj = this.skin = new Physijs.BoxMesh(aux.geometry, aux.material, this.mass);
        this.obj.setAngularFactor(new THREE.Vector3(0, 1, 0));
      } else {
        this.obj = aux;
      }
      this.obj.scale.x = this.obj.scale.y = this.obj.scale.z = this.scale;
      this.obj.updateMatrix();
      animHandler = THREE.AnimationHandler;
      _fn = function(i) {
        var animation, kfAnimation;
        animation = _this.kAnimations[i];
        animHandler.add(animation);
        kfAnimation = new THREE.KeyFrameAnimation(animation.node, animation.name);
        kfAnimation.timeScale = 1;
        _this.kfAnimations.push(kfAnimation);
        return kfAnimation.play(false, 0);
      };
      for (i = _i = 0, _ref4 = this.kAnimations.length - 1; 0 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
        _fn(i);
      }
      skelKeys = this.kAnimations[0].hierarchy[0].keys;
      _fn1 = function(i) {
        var kMatrix, vec;
        kMatrix = skelKeys[i].targets[0].data;
        vec = new THREE.Vector3().getPositionFromMatrix(kMatrix).sub(offset);
        return kMatrix.setPosition(vec);
      };
      for (i = _j = 0, _ref5 = skelKeys.length - 1; 0 <= _ref5 ? _j <= _ref5 : _j >= _ref5; i = 0 <= _ref5 ? ++_j : --_j) {
        _fn1(i);
      }
      addLines = function(obj) {
        var _k, _ref6, _results,
          _this = this;
        if (obj && obj.children && obj.children.length) {
          _results = [];
          for (i = _k = 0, _ref6 = obj.children.length - 1; 0 <= _ref6 ? _k <= _ref6 : _k >= _ref6; i = 0 <= _ref6 ? ++_k : --_k) {
            _results.push((function(i) {
              var geometry;
              geometry = new THREE.Geometry();
              geometry.vertices.push(obj.children[i].position);
              geometry.vertices.push(new THREE.Vector3());
              obj.add(new THREE.Line(geometry));
              return addLines(obj.children[i]);
            })(i));
          }
          return _results;
        }
      };
      addLines(this.skel);
      this.obj.add(this.skel);
      this.frame = 0;
      this.setAnimationByName('idle');
      this.hand = new Physijs.BoxMesh(new THREE.SphereGeometry(5), new THREE.MeshBasicMaterial(), this.mass / 100);
      this.obj.add(this.hand);
      return scene.add(this.obj);
    };

    ColladaObject.prototype.update = function(delta) {
      var currLength, i, kmatrix, _i, _j, _ref, _ref1;
      if (this.skin && this.currentAnimation) {
        for (i = _i = 0, _ref = this.skin.morphTargetInfluences.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          this.skin.morphTargetInfluences[i] = 0;
        }
        this.skin.morphTargetInfluences[this.currentAnimation.start + this.frame] = 1;
        currLength = this.currentAnimation.end - this.currentAnimation.start;
        if (this.frame < currLength - 1 || this.currentAnimation.looping) {
          this.frame = (this.frame + 1) % currLength;
        } else {
          this.setAnimationByName('idle');
        }
        for (i = _j = 0, _ref1 = this.kfAnimations.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          this.kfAnimations[i].setFrame(this.currentAnimation.start + this.frame);
        }
        kmatrix = new THREE.Matrix4().copy(this.skel.getObjectByName("ZOMBIE_R_Hand", true).matrixWorld);
        kmatrix = new THREE.Matrix4().getInverse(this.skel.matrixWorld).multiply(kmatrix);
        this.hand.matrixWorld = kmatrix;
        this.hand.__dirtyPosition = true;
        return this.hand.__dirtyRotation = true;
      }
    };

    ColladaObject.prototype.getPosition = function() {
      return this.obj.position;
    };

    ColladaObject.prototype.setAnimation = function(animation) {
      this.currentAnimation = animation;
      return this.frame = 0;
    };

    ColladaObject.prototype.setAnimationByName = function(animationName) {
      return this.setAnimation(this.animations[animationName]);
    };

    ColladaObject.prototype.getAnimationByName = function(animationName) {
      return this.animations[animationName];
    };

    ColladaObject.prototype.getAnimationByStartKey = function(key) {
      var anim;
      for (anim in this.animations) {
        if (this.animations[anim].start === key) {
          return this.animations[anim];
        }
      }
    };

    ColladaObject.prototype.getNextAnimation = function() {
      return this.getAnimationByStartKey((this.currentAnimation.end + 1) % (this.getMaxFrames() + 1));
    };

    ColladaObject.prototype.setNextAnimation = function() {
      return this.setAnimation(this.getNextAnimation());
    };

    ColladaObject.prototype.getMaxFrames = function() {
      var anim, maxFrames;
      maxFrames = 0;
      for (anim in this.animations) {
        if (this.animations[anim].end > maxFrames) {
          maxFrames = this.animations[anim].end;
        }
      }
      return maxFrames;
    };

    ColladaObject.prototype.move = function(direction) {
      var angle, angleDelta, axis, from;
      if (direction) {
        if (this.currentAnimation === this.getAnimationByName('idle')) {
          this.setAnimationByName('walk');
        }
        from = this.obj.getForward();
        angle = from.angleTo(direction);
        if (angle < 0.4 * Math.PI) {
          this.obj.position.add(from.multiplyScalar(this.speed));
          this.obj.__dirtyPosition = true;
        }
        if (angle > 0.02 * Math.PI) {
          axis = angle === Math.PI ? this.obj.up : new THREE.Vector3().crossVectors(from, direction).normalize();
          angleDelta = Math.min(this.speed * Math.PI, angle);
          this.obj.rotateOnAxis(new THREE.Vector3(0, axis.y, 0), angleDelta);
          return this.obj.__dirtyRotation = true;
        }
      } else {
        if (this.currentAnimation === this.getAnimationByName('walk')) {
          return this.setAnimationByName('idle');
        }
      }
    };

    ColladaObject.prototype.attack = function() {
      if (this.currentAnimation !== this.getAnimationByName('attack')) {
        return this.setAnimationByName('attack');
      }
    };

    return ColladaObject;

  })();

}).call(this);
