// Generated by CoffeeScript 1.4.0
(function() {

  THREE.Object3D.prototype.getForward = function() {
    return new THREE.Vector3(0, 0, 1).transformDirection(this.matrix);
  };

  THREE.Geometry.prototype.translate = function(offset) {
    var i, matrix, _i, _ref, _results,
      _this = this;
    matrix = new THREE.Matrix4().makeTranslation(offset.x, offset.y, offset.z);
    this.applyMatrix(matrix);
    if (this.morphTargets && this.morphTargets.length) {
      _results = [];
      for (i = _i = 0, _ref = this.morphTargets.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push((function(i) {
          var j, vertex, _j, _ref1, _results1;
          vertex = _this.morphTargets[i].vertices;
          if (vertex && vertex.length) {
            _results1 = [];
            for (j = _j = 0, _ref1 = vertex.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              _results1.push((function(j) {
                return vertex[j].applyMatrix4(matrix);
              })(j));
            }
            return _results1;
          }
        })(i));
      }
      return _results;
    }
  };

  THREE.Geometry.prototype.getCenter = function() {
    var bb;
    this.computeBoundingBox();
    bb = this.boundingBox;
    return new THREE.Vector3().addVectors(bb.min, bb.max).multiplyScalar(-0.5);
  };

  THREE.Geometry.prototype.center = function() {
    return this.translate(this.getCenter());
  };

  THREE.KeyFrameAnimation.prototype.setFrame = function(frame) {
    var h, _i, _ref, _results,
      _this = this;
    _results = [];
    for (h = _i = 0, _ref = this.hierarchy.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; h = 0 <= _ref ? ++_i : --_i) {
      _results.push((function(h) {
        var keys, obj, s, sids, _fn, _j, _ref1;
        keys = _this.data.hierarchy[h].keys;
        sids = _this.data.hierarchy[h].sids;
        obj = _this.hierarchy[h];
        if (keys.length) {
          _fn = function(s) {
            var key, sid;
            sid = sids[s];
            key = _this.getNextKeyWith(sid, h, frame);
            if (!!key) {
              return key.apply(sid);
            }
          };
          for (s = _j = 0, _ref1 = sids.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; s = 0 <= _ref1 ? ++_j : --_j) {
            _fn(s);
          }
          _this.data.hierarchy[h].node.updateMatrix();
          return obj.matrixWorldNeedsUpdate = true;
        }
      })(h));
    }
    return _results;
  };

}).call(this);
